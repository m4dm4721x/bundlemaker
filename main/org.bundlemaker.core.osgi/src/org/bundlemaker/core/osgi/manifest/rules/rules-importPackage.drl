package org.bundlemaker.core.osgi.manifest.rules

import org.bundlemaker.core.modules.IResourceModule;
import com.springsource.util.osgi.manifest.BundleManifest;
import org.bundlemaker.core.resource.IReference;
import org.bundlemaker.core.osgi.internal.manifest.IdentifiableBundleManifest;
import org.bundlemaker.core.osgi.exporter.ManifestConstants;
import org.bundlemaker.core.osgi.manifest.DependencyStyle;
import com.springsource.util.osgi.manifest.ImportedPackage;
import org.bundlemaker.core.osgi.internal.manifest.ReferencesCache;
import com.springsource.util.osgi.manifest.Resolution;
import org.bundlemaker.core.modules.IModule;
import org.bundlemaker.core.modules.IModuleIdentifier;
import com.springsource.util.osgi.manifest.RequiredBundle;
import com.springsource.util.osgi.VersionRange;
import org.bundlemaker.core.osgi.manifest.IManifestPreferences;
import com.springsource.util.osgi.manifest.RequiredBundle.Visibility;
import org.bundlemaker.core.osgi.internal.manifest.DroolsManifestUtils;
import org.bundlemaker.core.modules.query.ReferenceQueryFilters;

// the global definitions
global IResourceModule _resourceModule;
global IModularizedSystem _modularizedSystem;
global IManifestPreferences _manifestPreferences;
global ReferencesCache _referencesCache;
global IdentifiableBundleManifest _bundleManifest;
global IdentifiableBundleManifest _originalManifest;
global IdentifiableBundleManifest _manifestTemplate;

/**
 * Eingabe:
 * - IModularizedSystem
 * - IResourceModule
 * - BundleManifest
 * - IExportPackagePreferences
 */
/**
rule "strict import packages - create imported package"
when
    eval (_manifestPreferences.getDependencyStyle().equals(DependencyStyle.STRICT_IMPORT_PACKAGE))
    $referencedPackageName : String() from _resourceModule.getReferencedPackageNames(true, true, true)
then
   // create a new importedPackage
   ImportedPackage importedPackage = _bundleManifest.getImportPackage().addImportedPackage($referencedPackageName);
   
   // add it
   insert( importedPackage );
end

rule "set imported package optional if not exporter exists"
when
    $importedPackage : ImportedPackage()
    not( eval( _referencesCache.hasExportingModules($importedPackage.getPackageName()) ) )
then
   $importedPackage.setResolution(Resolution.OPTIONAL);
end
**/

rule "RequiredBundle: strict require bundle - "
when
    // assure that dependencystyle is 'DependencyStyle.STRICT_REQUIRE_BUNDLE'
    eval (DependencyStyle.STRICT_REQUIRE_BUNDLE.equals(_manifestPreferences.getDependencyStyle()))
    // for all referenced package names
    $referencedPackageName : String() from _resourceModule.getReferencedPackageNames(ReferenceQueryFilters.createReferenceFilter(true, true, true, true, _manifestPreferences.isConsiderIndirectReferences()))
    // for all exporting modules of a referenced package name
    $exportingModule : IModule() from _referencesCache.getExportingModules($referencedPackageName)
    // get the host bundle
    $exportingHostModule : IModule() from ManifestUtils.getFragmentHost($exportingModule)
	// get the symbolicname of the host bundle
    $symbolicName : String() from $exportingHostModule.getModuleIdentifier().getName()
    // assure that the required has not been created yet
   	not ( RequiredBundle(bundleSymbolicName == $symbolicName) )
    // assure that the required bundle is not excluded or is the host for this fragment
    eval ( !ManifestUtils.isExcludedRequiredBundle(_manifestTemplate, $symbolicName) && 
           !(ManifestUtils.isFragment(_resourceModule) && ManifestUtils.getFragmentHost(_resourceModule).equals($exportingHostModule)) )
then
   // create a required bundle
   RequiredBundle requiredBundle = _bundleManifest.getRequireBundle().addRequiredBundle($symbolicName);
   
   // set a version range if multiple versions exist
   if (_modularizedSystem.getModules($symbolicName).size() > 1) {
     requiredBundle.setBundleVersion(new VersionRange("[" + $exportingHostModule.getModuleIdentifier().getVersion() + "," + $exportingHostModule.getModuleIdentifier().getVersion() + "]"));
   }
   
   // set the visibility to reexport
   if (_manifestPreferences.isReexportRequiredBundles()) {
     requiredBundle.setVisibility(Visibility.REEXPORT);
   }
   
   // add to memory
   insert( requiredBundle );
end

rule "RequiredBundle - Template"
salience 50
when
    $requiredBundle :  RequiredBundle() from _manifestTemplate.getRequireBundle().getRequiredBundles();
    not ( RequiredBundle(bundleSymbolicName == $requiredBundle.bundleSymbolicName) )
then
    _bundleManifest.getRequireBundle().getRequiredBundles().add($requiredBundle);
    insert( $requiredBundle );
end

rule "RequiredBundle: add transitive closure"
salience -20
when
   // assure that dependencystyle is 'DependencyStyle.STRICT_REQUIRE_BUNDLE'
   eval (DependencyStyle.STRICT_REQUIRE_BUNDLE.equals(_manifestPreferences.getDependencyStyle()))
   $module : IModule() from _modularizedSystem.getTransitiveReferencedModules(_resourceModule, ReferenceQueryFilters.ALL_DIRECT_EXTERNAL_REFERENCES_QUERY_FILTER).getReferencedModules()
   $moduleName : String() from $module.getModuleIdentifier().getName()
   not (RequiredBundle(bundleSymbolicName == $moduleName))
   $executionEnvironmentName : String() from _modularizedSystem.getExecutionEnvironment().getModuleIdentifier().getName()
   eval (! $executionEnvironmentName.equals($moduleName))
then
   _bundleManifest.getTransitiveClosure().add($moduleName);
end

rule "RequiredBundle: replace require bundle 'system.bundle' "
salience -50
when
   $symbolicName : String() from _modularizedSystem.getExecutionEnvironment().getModuleIdentifier().getName()
   $requiredBundle : RequiredBundle(bundleSymbolicName == $symbolicName)
then
   // create a required bundle
   _bundleManifest.getRequireBundle().getRequiredBundles().remove($requiredBundle);
   RequiredBundle systemBundle = _bundleManifest.getRequireBundle().addRequiredBundle("system.bundle");
   
   // set the visibility to reexport
   if (_manifestPreferences.isReexportRequiredBundles()) {
     systemBundle.setVisibility(Visibility.REEXPORT);
   }
end
