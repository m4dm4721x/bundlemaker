package org.bundlemaker.core.osgi.manifest.rules

import org.bundlemaker.core.modules.IModularizedSystem;
import org.bundlemaker.core.modules.IResourceModule;
import org.bundlemaker.core.resource.IType;
import com.springsource.util.osgi.manifest.BundleManifest;
import com.springsource.util.osgi.manifest.ExportedPackage;
import com.springsource.util.osgi.manifest.ExportPackage;
import com.springsource.util.osgi.manifest.parse.HeaderDeclaration;
import org.osgi.framework.Version;
import org.bundlemaker.core.osgi.internal.manifest.DroolsManifestUtils;
import org.bundlemaker.core.osgi.internal.manifest.IdentifiableBundleManifest;
import org.bundlemaker.core.osgi.exporter.ManifestConstants;
import org.bundlemaker.core.osgi.utils.ManifestUtils;
import org.bundlemaker.core.osgi.manifest.IManifestPreferences;
import org.bundlemaker.core.osgi.internal.manifest.ReferencesCache;

// the global definitions
global IResourceModule _resourceModule;
global IModularizedSystem _modularizedSystem;
global IManifestPreferences _manifestPreferences;
global ReferencesCache _referencesCache;
global IdentifiableBundleManifest _bundleManifest;
global IdentifiableBundleManifest _originalManifest;
global IdentifiableBundleManifest _manifestTemplate;

rule "export the package of a type (if it's not already exported)"
when
    $type : IType() from _resourceModule.getContainedTypes()
    eval ($type.getPackageName().trim().length() > 0)
    eval ($type.hasSourceResource() || ! (_manifestPreferences.isSourceManifest()))
    not ( ExportedPackage( packageName == $type.packageName ) )
then
   // create a new ExportedPackage
   ExportedPackage exportedPackage = _bundleManifest.getExportPackage().addExportedPackage($type.getPackageName());
   insert( exportedPackage );
end

rule "set export package version"
when
    $exportedPackage : ExportedPackage( version.toString != _resourceModule.moduleIdentifier.version)
    IManifestPreferences( noExportPackageVersion == false ) 
    eval( ManifestUtils.isValidOSGiVersion(_resourceModule.getModuleIdentifier().getVersion()) )
then
   $exportedPackage.setVersion(new Version(_resourceModule.getModuleIdentifier().getVersion()));
end

rule "set attributes and directives from template manifest"
// We set the salience to -100 to ensure that the rule will be fired as the last rule:
// template entries *always* overwrite computed values!
salience -100
when
    $manifestTemplate : IdentifiableBundleManifest( role == IdentifiableBundleManifest.MANIFEST_TEMPLATE )
    $exportedPackage : ExportedPackage()
    eval ( DroolsManifestUtils.hasMostSpecificPackageTemplate($manifestTemplate, ManifestConstants.HEADER_EXPORT_TEMPLATE, $exportedPackage.getPackageName()) )
then
    HeaderDeclaration header = DroolsManifestUtils.getMostSpecificPackageTemplate($manifestTemplate, ManifestConstants.HEADER_EXPORT_TEMPLATE, $exportedPackage.getPackageName());
    $exportedPackage.getAttributes().putAll(header.getAttributes());
    $exportedPackage.getDirectives().putAll(header.getDirectives());
end

//
// TODO: 
// - Support for "uses" directive
// - Support for "mandatory" directive
// - Support for "include" directive
// - Support for "exclude" directive
// - Support for private packages
// - Support for private types 


